import os
import re


def write_test_file(function_name, test_code, output_dir):
    os.makedirs(output_dir, exist_ok=True)
    test_file_name = f"test_{function_name}.py"
    file_path = os.path.join(output_dir, test_file_name)

    with open(file_path, "w") as f:
        f.write(test_code)

    print(f"✅ Test written to: {file_path}")


def postprocess_test_code(test_code: str, function_name: str, module_name: str) -> str:
    """
    Adjusts the test code generated by LLM:
    - Replaces the module name (your_module → module_name).
    - Replaces the function name if LLM used a different one (detected by regex).
    - Adds optional warning docstring.

    Args:
        test_code (str): The generated test code.
        function_name (str): The name of the function being tested.
        module_name (str): The name of the module containing the function.

    Returns:
        str: The postprocessed test code.
    """

    # Replaces the import module
    test_code = test_code.replace("your_module", module_name)

    # Detects if it used an incorrect function name
    match = re.search(r"def test_(\w+)\(", test_code)
    if match:
        used_name = match.group(1)
        if used_name != function_name:
            test_code = test_code.replace(used_name, function_name)

    # Removes markdown ```python``` if it comes from OpenAI
    test_code = test_code.replace("```python", "").replace("```", "")

    return test_code.strip()


def clean_llm_output(text: str) -> str:
    """
    Cleans the text generated by the LLM:
    - Removes markdown code blocks.
    - Removes clarifications like 'make sure to replace ...'.
    - Returns only the code.
    """
    # Removes ```python ... ```
    text = re.sub(r"```(?:python)?", "", text)

    # Removes lines at the end that start with 'Make sure' or other clarifications
    lines = text.strip().splitlines()
    lines = [
        line
        for line in lines
        if not re.match(r"(?i)^make sure|^note|^replace", line.strip())
    ]

    return "\n".join(lines).strip()
