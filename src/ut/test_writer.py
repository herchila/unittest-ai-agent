"""Automated Unit Test Generation CLI with AI."""
import os
import re
from pathlib import Path

from ut.cli.commands.constants import DEF_TEST_STRING


def write_test_file(function_name, test_code, output_dir):
    """Write the generated test code to a file.

    Args:
        function_name (str): The name of the function being tested.
        test_code (str): The generated test code.
        output_dir (str): The directory where the test file will be saved.

    Returns:
        str: The path to the created test file.
    """

    os.makedirs(output_dir, exist_ok=True)
    test_file_name = f"{function_name}.py"
    file_path = os.path.join(output_dir, test_file_name)

    with open(file_path, "w") as f:
        f.write(test_code)

    print(f"✅ Test written to: {file_path}")
    return file_path


def postprocess_test_code(
    test_code: str,
    function_name: str,
    module_name: str,
) -> str:
    """Adjust the test code generated by LLM.

        - Replaces the module name (your_module → module_name).
        - Replaces the function name if LLM used a different one (detected by regex).
        - Adds optional warning docstring.

    Args:
        test_code (str): The generated test code.
        function_name (str): The name of the function being tested.
        module_name (str): The name of the module containing the function.

    Returns:
        str: The postprocessed test code.
    """

    # Replaces the import module
    test_code = test_code.replace("your_module", module_name)

    # Detects if it used an incorrect function name
    match = re.search(r"def test_(\w+)\(", test_code)
    if match:
        used_name = match.group(1)
        if used_name != function_name:
            test_code = test_code.replace(used_name, function_name)

    # Removes markdown ```python``` if it comes from OpenAI
    test_code = test_code.replace("```python", "").replace("```", "")

    return test_code.strip()


def extract_imports_and_functions(test_code: str) -> tuple[set, list]:
    """
    Extract imports and test functions from generated test code.

    Args:
        test_code (str): The generated test code.

    Returns:
        tuple: (set of import statements, list of test function code blocks)
    """
    lines = test_code.strip().split("\n")
    imports = set()
    functions = []
    current_function: list[str] = []
    in_function = False
    decorator_lines = []

    for line in lines:
        # Skip malformed lines and comments
        if line.strip() == ")" or line.strip().startswith("#") and not in_function:
            continue

        # Check if it's an import statement
        if line.strip().startswith(("import ", "from ")) and not in_function:
            # Clean up malformed imports
            if "from test_" not in line and "TODO:" not in line:
                imports.add(line.strip())
        # Handle decorators
        elif line.strip().startswith("@"):
            if current_function:
                # Save the previous function
                functions.append("\n".join(current_function))
                current_function = []
            decorator_lines.append(line)
            in_function = False
        # Check if it's the start of a function
        elif line.startswith(DEF_TEST_STRING):
            if current_function:
                # Save the previous function
                functions.append("\n".join(current_function))
                current_function = []
            # Add any decorators to this function
            if decorator_lines:
                current_function.extend(decorator_lines)
                decorator_lines = []
            in_function = True
            current_function.append(line)
        # If we're in a function, keep adding lines
        elif in_function:
            # Check if this line is not indented (end of function)
            if line and not line[0].isspace() and not line.startswith(("@", "#")):
                # End of function - check if it's complete
                if current_function and len("\n".join(current_function).strip()) > 0:
                    functions.append("\n".join(current_function))
                current_function = []
                in_function = False
                decorator_lines = []
                # Check if this line is an import
                if line.strip().startswith(("import ", "from ")):
                    if "from test_" not in line and "TODO:" not in line:
                        imports.add(line.strip())
            else:
                current_function.append(line)

    # Don't forget the last function if it's complete
    if current_function and len("\n".join(current_function).strip()) > 0:
        # Check if function is complete (has at least assert or pass)
        func_content = "\n".join(current_function)
        if (
            "assert" in func_content
            or "pass" in func_content
            or "raise" in func_content
        ):
            functions.append(func_content)

    # Remove duplicate functions (same name)
    seen_names = set()
    unique_functions = []
    for func in functions:
        # Extract function name
        for line in func.split("\n"):
            if line.startswith(DEF_TEST_STRING):
                func_name = line.split("(")[0].replace("def ", "")
                if func_name not in seen_names:
                    seen_names.add(func_name)
                    unique_functions.append(func)
                break

    return imports, unique_functions


def combine_test_code(
    imports: set, test_functions: list, module_name: str, module_import_path: str
) -> str:
    """
    Combine imports and test functions into a single, well-formatted test file.

    Args:
        imports: Set of import statements
        test_functions: List of test function code blocks
        module_name: Name of the module being tested
        module_import_path: Import path for the module

    Returns:
        str: Complete test file content
    """
    # Organize imports
    stdlib_imports = []
    third_party_imports = []
    local_imports = []

    # Common standard library modules
    stdlib_modules = [
        "unittest",
        "datetime",
        "os",
        "sys",
        "json",
        "typing",
        "collections",
        "itertools",
        "functools",
        "pathlib",
        "re",
    ]

    # Common third-party test modules
    third_party_modules = [
        "pytest",
        "mock",
        "unittest.mock",
        "numpy",
        "pandas",
        "requests",
        "flask",
        "django",
        "fastapi",
    ]

    for imp in sorted(imports):
        # Skip malformed imports
        if not imp.startswith(("import ", "from ")):
            continue

        # Determine import type
        is_stdlib = any(module in imp for module in stdlib_modules)
        is_third_party = any(module in imp for module in third_party_modules)

        if is_stdlib:
            stdlib_imports.append(imp)
        elif is_third_party:
            third_party_imports.append(imp)
        elif module_import_path in imp or imp.startswith(f"from {module_import_path}"):
            local_imports.append(imp)
        else:
            # Default to third-party for unknown imports
            third_party_imports.append(imp)

    # Build the file content
    content_parts = []

    # Add file docstring
    content_parts.append(f'"""Tests for {module_name} module."""')
    content_parts.append("")

    # Add imports (PEP 8: standard library, blank line, third-party, blank line, local)
    if stdlib_imports:
        content_parts.extend(stdlib_imports)
        content_parts.append("")

    # Always include pytest if not already present
    if not any("pytest" in imp for imp in third_party_imports):
        third_party_imports.insert(0, "import pytest")

    if third_party_imports:
        content_parts.extend(third_party_imports)
        content_parts.append("")

    if local_imports:
        # Deduplicate and refine local imports
        refined_imports = refine_local_imports(
            local_imports, module_import_path, module_name
        )
        content_parts.extend(refined_imports)
        content_parts.append("")

    # Add two blank lines before test functions (PEP 8)
    content_parts.append("")

    # Add test functions with proper spacing
    for i, func in enumerate(test_functions):
        if i > 0:
            content_parts.append("")  # Two blank lines between functions
            content_parts.append("")
        content_parts.append(func)

    # Add final newline
    content_parts.append("")

    return "\n".join(content_parts)


def refine_local_imports(
    imports: list, module_import_path: str, file_stem: str
) -> list:
    """
    Refine local imports to avoid duplicates and ensure correctness.

    Args:
        imports: List of import statements
        module_import_path: The correct import path for the module
        file_stem: The name of the file without extension

    Returns:
        list: Refined import statements
    """
    refined = set()
    imported_items = set()

    # Common placeholder modules that LLMs use
    placeholder_modules = [
        "some_module",
        "your_module",
        "module_name",
        "my_module",
        "sample_module",
        "<module_name>",
        "path.to.module",
        "test_" + file_stem,  # Avoid self-imports
        file_stem if file_stem.startswith("test_") else None,
    ]

    for imp in imports:
        # Skip malformed imports
        if ")" in imp and "import" not in imp:
            continue

        # Skip TODO comments
        if "TODO:" in imp or "#" in imp:
            continue

        # Replace placeholder modules with actual module path
        for placeholder in placeholder_modules:
            if placeholder and placeholder in imp:
                imp = imp.replace(placeholder, module_import_path)

        # Parse the import statement
        if "from " in imp and " import " in imp:
            parts = imp.split(" import ")
            if len(parts) == 2:
                from_part = parts[0].replace("from ", "").strip()
                import_part = parts[1].strip()

                # Skip if it's trying to import from the test file itself
                if "test_" in from_part:
                    continue

                # Use the correct module path for local imports
                if from_part in placeholder_modules or from_part == module_import_path:
                    from_part = module_import_path

                # Handle multiple imports
                items = [item.strip() for item in import_part.split(",")]
                for item in items:
                    if item and item != "*":
                        import_key = f"{from_part}.{item}"
                        if import_key not in imported_items:
                            imported_items.add(import_key)
                            refined.add(f"from {from_part} import {item}")
        elif imp.startswith("import "):
            # Handle simple imports
            module = imp.replace("import ", "").strip()
            if module not in placeholder_modules and "test_" not in module:
                refined.add(imp)

    # If no specific imports were found, add a generic one
    if not any(module_import_path in imp for imp in refined):
        # Try to import the specific function being tested
        refined.add(f"from {module_import_path} import *")

    return sorted(list(refined))


def postprocess_test_code_enhanced(
    test_code: str,
    function_name: str,
    module_import_path: str,
    module_name: str,
) -> str:
    """Enhanced post-processing that handles import paths correctly \
    for any project structure.

    Args:
        test_code (str): The test code to process.
        function_name (str): The name of the function being tested.
        module_import_path (str): The import path of the module being tested.
        module_name (str): The name of the module being tested.

    Returns:
        str: The processed test code.
    """

    import re

    # Remove markdown code blocks if present
    test_code = re.sub(r"```(?:python)?", "", test_code)
    test_code = test_code.strip("```").strip()

    placeholders = [
        "your_module",
        "module_name",
        "my_module",
        "sample_module",
        "<module_name>",
        "path.to.module",
    ]

    for placeholder in placeholders:
        test_code = test_code.replace(
            f"from {placeholder}", f"from {module_import_path}"
        )
        test_code = test_code.replace(
            f"import {placeholder}", f"import {module_import_path}"
        )

    if "from ." in test_code:
        # Convert relative imports to absolute based on test location
        test_code = re.sub(
            r"from \.([\w\.]*) import",
            f"from {module_import_path}\\1 import",
            test_code,
        )

    # Ensure the import statement exists if not present
    if module_import_path not in test_code and function_name in test_code:
        import_line = f"from {module_import_path} import {function_name}\n\n"
        if not test_code.startswith("import") and not test_code.startswith("from"):
            test_code = import_line + test_code

    # Clean up any double imports or malformed imports
    lines = test_code.split("\n")
    seen_imports = set()
    cleaned_lines = []

    for line in lines:
        if line.strip().startswith(("import ", "from ")):
            if line not in seen_imports:
                seen_imports.add(line)
                cleaned_lines.append(line)
        else:
            cleaned_lines.append(line)

    return "\n".join(cleaned_lines).strip()


def append_test_to_file(test_file_path: Path, test_code: str, function_name: str):
    """Append a test function to an existing test file or create a new one.

    Args:
        test_file_path (Path): The path to the test file.
        test_code (str): The code of the test function.
        function_name (str): The name of the function being tested.
    """

    if test_file_path.exists():
        with open(test_file_path, "r", encoding="utf-8") as f:
            existing_content = f.read()

        new_imports, new_functions = extract_imports_and_functions(test_code)
        existing_imports, existing_functions = extract_imports_and_functions(
            existing_content
        )

        all_imports = existing_imports.union(new_imports)
        all_functions = existing_functions + new_functions

        # Get module info from the existing imports
        module_import_path = None
        for imp in existing_imports:
            if "from " in imp and " import " in imp and "pytest" not in imp:
                module_import_path = (
                    imp.split(" import ")[0].replace("from ", "").strip()
                )
                break

        if not module_import_path:
            module_import_path = "your_module"  # Fallback

        combined_code = combine_test_code(
            all_imports,
            all_functions,
            test_file_path.stem.replace("test_", ""),
            module_import_path,
        )

        with open(test_file_path, "w", encoding="utf-8") as f:
            f.write(combined_code)
    else:
        with open(test_file_path, "w", encoding="utf-8") as f:
            f.write(test_code)
